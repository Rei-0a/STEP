## 1. 概要

課題5に引き続き、TSP(Traveling Salesperson Problem)について考える。

```

python -m http.server # For Python 3

python -m SimpleHTTPServer 8000 # If you don’t want to install Python 3

```

を実行した後に、[リンク](http://localhost:8000/visualizer/build/default/)を開くことでビジュアライズ可能。

## 2. 各課題の内容

TSPを実際に実装して、様々なアルゴリズムや工夫をしてみる。

[サンプルコード](https://github.com/hayatoito/google-step-tsp)を用いた。

貪欲法を用いた後に、2-opt法を用いたときの経路長([コード](https://github.com/Rei-0a/STEP/tree/main/05_TSPChallenge))よりも、短くなるようなアルゴリズムを考える。また、今回用いるデータは、都市の長さ `N`が、`N=2048`のとき、`N=8192`のときを考える。

## 3. 提案する設計

### 1 2-opt法

```(python)

     2-opt

       A     B         \   A -----→ B

         \ /   ↖  ----- \             ↘

          /     X        〉            X 

         ↙ ↘   ↗  ----- /             ↙

       C     D         /   C ←----- D

```

ルート内に、左のようなクロスが発生してしまっているとき、[A,D,X,B,C] ===> [A,B,Xの逆,D,C]のように、その紐をほどき、クロスをなくした。

1. 上記図のA->D　エッジを探索

  a. 上記図のB->C　エッジを探索

  b. A -> D とB -> C　が異なるエッジのとき

    (A->DとB->Cの長さ) > (A->BとC->Dの長さ)なら、D,X,Bの配列を、B,Xの逆順, Dの順に格納する

2.1. を、変更がなくなるまで繰り返す

### 2. 蟻コロニー最適化 🐜

貪欲法→2opt法を行ったあとの経路に重みづけをした状態で、アリコロニー最適化を行う。

1. エージェント(蟻)と重み行列の初期化を行う(貪欲法などで得た解に初期重みを追加する)
2. 各エージェントに対して以下の処理を繰り返す。
   1. (まだ通っていない)各都市に対して、重みとヒューリスティックな情報(今回は距離の逆数とした)に基づいて解の選択を行う。(*)
   2. 重みを更新する(**)
3. 最も良い成績のエージェントの解を出力する。

##### (*) 解の選択方法

今、都市 $i$にいるとする。

また、まだ訪問していない都市の集合を $Ω$とする。

このとき、各アリが現在の都市 $i$ から次の都市 $j\in\Omega$ を選択する確率 $P_{ij}$ を以下のように定義した

$$
P_{ij} = \frac{\tau_{ij}^{\alpha} \cdot \eta_{ij}^{\beta}}{\sum_{k \in \text{allowed}} \tau_{ik}^{\alpha} \cdot \eta_{ik}^{\beta}}
$$

- $\tau_{ij}$：辺 $(i, j)$ 上の重み量
- $\eta_{ij} = \frac{1}{d_{ij}}$：都市 $i$ から $j$ へのヒューリスティック情報（距離の逆数）
- $\alpha$：重みの重要度を調整するパラメータ（例：1）
- $\beta$：ヒューリスティック情報の重要度を調整するパラメータ（例：2）

  この確率に基づいて、ランダムに次の都市を選んだ。

##### (**) 重みの更新

今までの重みをある割合 `evapotarion_tate`倍して、減少させた。その後、解として得たルートに、そのルートの総距離の逆数だけ重みを足しいれた。

##### 変数の設定

重みの追加を行うときを、最適値の105%以内の値にするよりも、そのままの方がよさそうであった

##### 📚 参考文献

1. ganyariya, 「【アントコロニー最適化(ACO)を救いたい」, Qiita, 2021.[https://qiita.com/ganyariya/items/25824f1502478a673005](https://qiita.com/ganyariya/items/25824f1502478a673005)
2. 田邊遼司, 「進化計算アルゴリズムの改良研究～アリコロニー最適化を例に～」, 横浜国立大学 スライド資料.
   [https://ryojitanabe.github.io/pdf/t-ynu-oa_slides.pdf](https://ryojitanabe.github.io/pdf/t-ynu-oa_slides.pdf)

## 4. 実行結果

ひとまず、N=128でいくつか実験をした。
初期解として与えるものを変化させた。

- 初期解としてランダムなものを与えたとき解 > 11544.618730372871
![alt text](Image/aco_random.png)

- 貪欲法で得た解を初期解にしたとき > 11834.474843435244

![貪欲法](Image/aco_greedy.png)

- 貪欲法→2optで得た解を初期解にしたとき > 11124.659836444922
![alt text](Image/aco_greedyto2opt.png)

**[問題点?]**
2-opt法を初期解とする方がいい気がするが、2-optがかなり良い局所解だった場合に、そこから抜け出せない気がしている。

- 重みを更新するときを、今得た最適解から、最適値の大きさが105%以内の解のみにした場合 > 11124.659836444918

![alt text](Image/aco_limit_add_weight.png)

- 重みを更新するときを、今得た最適解から、最適値の大きさが110%以内の解のみにした場合 > 11124.659836444918
![alt text](Image/aco_limit_add_weight_110.png)

**[問題点?]**
振動がなくなったが、これをしてしまうと、局所解から抜け出せない気がする。


N=256のときにどうなるか、実行をしてみたけど、なんでこうなるのかわからない結果になってしまった

![alt text](Image/aco_N256_1.png)




## 6. Open Questions
## 7. 計算量
